/****************************************************************************
 * KONOHA2 COPYRIGHT, LICENSE NOTICE, AND DISCRIMER
 *
 * Copyright (c) 2006-2012, Kimio Kuramitsu <kimio at ynu.ac.jp>
 *           (c) 2008-      Konoha Team konohaken@googlegroups.com
 * All rights reserved.
 *
 * You may choose one of the following two licenses when you use konoha.
 * If you want to use the latter license, please contact us.
 *
 * (1) GNU General Public License 3.0 (with K_UNDER_GPL)
 * (2) Konoha Non-Disclosure License 1.0
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/* ************************************************************************ */

/* ************************************************************************ */

#include"commons.h"
#include"../../include/konoha2/konohalang.h"
#ifdef K_USING_POSIX_
#include <unistd.h>
#endif

/* ************************************************************************ */

#ifdef __cplusplus
extern "C" {
#endif


/* ------------------------------------------------------------------------ */
/* [opt] */

static void opt_W(CTX, int mode, const char *optstr)
{

}

static kbool_t isCompileOnly = 0;
static kbool_t isInteractiveMode = 0;

static void opt_i(CTX, int mode, const char *optstr)
{
	isInteractiveMode = 1;
}

kbool_t knh_isCompileOnly(CTX)
{
	return isCompileOnly;
}

void knh_setCompileMode(CTX, int mode)
{
	isCompileOnly = mode;;
}

static void opt_c(CTX, int mode, const char *optstr)
{
	isCompileOnly = 1;
}

static void opt_g(CTX, int mode, const char *optstr)
{
	CTX_setDebug(_ctx, 1);
}

static void opt_O(CTX, int mode, const char *optstr)
{
	DBG_P("OPTIMIZATION %d", mode);
	if(mode == 0) {
		//DP(_ctx->gma)->cflag = 0; // NOTHING
	}
}

static kbool_t isActorMode = 0;
static int port = 0;

static void opt_p(CTX, int mode, const char *optstr)
{
	isActorMode = 1;
	port = mode;
}

/* ----------------------------------------------------------------------- */

void knh_loadScriptPackageList(CTX, const char *pkglist)
{
	if(pkglist != NULL) {
		kbytes_t t = {{pkglist}, knh_strlen(pkglist)};
		char buf[256];
		size_t i = 0;
		int isExists = 0;
		L_NEXT:;
		isExists = 0;
		while(i < t.len + 1) {
			char *c = buf;
			while(i < t.len + 1) {
				int ch = t.ubuf[i];
				i++;
				if(ch ==':' || ch == ';' || ch == ',' || ch == 0) {
					*c = 0;
					DBG_P("loading '%s'", buf);
					if(!knh_loadPackage(_ctx, B(buf)) && isExists == 0) {
						KNH_LOG("package not found: package=%s", buf+8);
					}
					goto L_NEXT;
				}
				else {
					if(ch == '?') {
						isExists = 1; continue;
					}
					*c = ch;
				}
				c++;
				if(!(c - buf < 256)) {
					KNH_LOG("too long name %s", pkglist);
					return ;
				}
			}
		}
	}
}

static void knh_setStartUpPackage(CTX, int mode, const char *optstr)
{
	if(optstr != NULL) {
		knh_loadScriptPackageList(_ctx, optstr);
	}
}

static void opt_version(CTX, int mode, const char *optstr)
{
	if(mode == 0) {
#if defined(K_USING_MINGW_)
		fprintf(stdout, "konoha%d-%d\n", (int)sizeof(void*) * 8, (int)K_REVISION);
#else
		fprintf(stdout, "konoha%d-%d-%d\n", (int)sizeof(void*) * 8, (int)K_REVISION, (int)getppid());
#endif /* defined(K_USING_MINGW_) */
	}
	else {
		dump_sysinfo(NULL, NULL, 1/*ALL*/);
	}
	exit(0);
}

static const char *HELPMSG =
		"usage: konoha [options]  [file | -]\n"
		"options and arguments (and corresponding environment variables):\n"
		"-a      : audit\n"
		"-c      : compile and verification only (never running)\n"
		"-g      : debug support for testing script\n"
		"-h      : print this help message and exit (also --help)\n"
		"-i      : invoke interactive shell after running script\n"
		"-l file : logging to file\n"
		"-O      : optimize generated bytecode slightly\n"
		"-p      : port number for actor\n"
		"-v      : verbose; -v0 is a strong system-level verbose\n"
		"-V      : show version and sysinfo and exit (also --version)\n"
		"-W arg  : warning control in compilation\n"
		"file    : program read from script file\n"
		"-       : program read from stdin\n"
		"\n"
		"Other environment variables:\n"
		"KONOHAHOME  : alternate to %s\n"
		"KONOHAENC   : alternate to %s\n"
		"\n";

static void opt_help(CTX, int mode, const char *optstr)
{
	kString* home = knh_getPropertyNULL(_ctx, STEXT("konoha.home.path"));
	fprintf(stdout, HELPMSG, S_text(home), knh_getSystemEncoding());
	exit(0);
}

/* ----------------------------------------------------------------------- */

typedef void (*knh_Fsetopt)(CTX, int, const char *);

#define OPT_EMPTY    0
#define OPT_NUMBER   1
#define OPT_STRING   2
#define OPT_(O)      O, (sizeof(O)-1)

typedef struct {
	const char *name;
	size_t len;
	int type;
	void (*setopt)(CTX, int, const char *);
} knh_optdata_t ;

static void opt_dummy(CTX, int mode, const char *optstr)
{
}

static knh_optdata_t optdata[] = {
	{OPT_("-a"), OPT_NUMBER, opt_dummy},
	{OPT_("-c"), OPT_EMPTY, opt_c},
	{OPT_("-i"), OPT_EMPTY, opt_i},
	{OPT_("-g"), OPT_NUMBER, opt_g},
	{OPT_("-v"), OPT_NUMBER, opt_dummy},
	{OPT_("-l"), OPT_STRING, opt_dummy},
	{OPT_("-O"), OPT_NUMBER, opt_O},
	{OPT_("-P"), OPT_STRING, knh_setStartUpPackage},
	{OPT_("-p"), OPT_NUMBER, opt_p},
	{OPT_("-W"), OPT_NUMBER, opt_W},
	{OPT_("-h"), OPT_EMPTY, opt_help},
	{OPT_("--verbose:gc"), OPT_EMPTY, opt_dummy},
	{OPT_("--verbose:lang"), OPT_EMPTY, opt_dummy},
	{OPT_("--verbose:pref"), OPT_EMPTY, opt_dummy},
//	{"--utest", OPT_EMPTY, opt_utest},
	{OPT_("--help"), OPT_EMPTY, opt_help},
	{OPT_("--enforce-secfileidty"), OPT_STRING, opt_dummy},
	{OPT_("--logcached"), OPT_STRING, opt_dummy},
	{OPT_("-V"), OPT_NUMBER, opt_version},
	{OPT_("--version"), OPT_NUMBER, opt_version},
	{NULL, 0, OPT_EMPTY, NULL}, // END
};

static knh_optdata_t *knh_getoptdata(const char *name)
{
	knh_optdata_t *d = optdata;
	while(d->name != NULL) {
		if(knh_strncmp(d->name, name, d->len) == 0) {
			return d;
		}
		d++;
	}
	return NULL;
}

static int knh_parseopt(CTX, int argc, const char **argv)
{
	int n;
	for(n = 1; n < argc; n++) {
		const char *t = argv[n];
		if(t[0] == '-' && (isalnum(t[1]) || t[1] == '-')) {
			knh_optdata_t *d = knh_getoptdata(t);
			int optnum = 1;              // default
			const char* optstr = NULL;   // default
			if(d == NULL) {
				opt_help(_ctx, optnum, optstr);
			}
			if(d->type == OPT_NUMBER) {
				t += d->len;
				if(t[0] == '=') t++;
				if(isalnum(t[0])) {
					kint_t v = 0;
					knh_bytes_parseint(B((char*)t), &v);
					optnum = (int)v;
				}
			}
			else if(d->type == OPT_STRING) {
				t += d->len;
				if(t[0] == '=') {
					optstr = t + 1;
				}
				else if(t[0] != 0) {
					optstr = t;
				}
				else if(n + 1 < argc) {
					n++;
					optstr = argv[n];
					if(optstr[0] == '-') {
						n--; optstr = NULL;
					}
				}
			}
			d->setopt(_ctx, optnum, optstr);
			continue;
		}
		break;
	}
	return n;
}

static kbytes_t knh_bytes_nsname(kbytes_t t)
{
	size_t i, s = 0;
	for(i = t.len - 1; i > 0; i--) {
		if(t.utext[i] == '/' || t.utext[i] == '\\') {
			s = i + 1;
			break;
		}
	}
	for(i = s; i < t.len; i++) {
		if(t.utext[i] == '.') {
			t.utext = t.utext + s;
			t.len = i - s;
			return t;
		}
	}
	t.utext = t.utext + s;
	t.len = t.len - s;
	return t;
}

static void knh_parsearg(CTX, int argc, const char **argv)
{
	int i;
	kArray *a = new_Array(_ctx, CLASS_String, argc);
	for(i = 1; i < argc; i++) {
		kArray_add(a, new_kString(argv[i], knh_strlen(argv[i]), SPOL_TEXT|SPOL_POOL));
	}
	knh_DictMap_set(_ctx, ctx->share->props, new_T("script.argv"), a);
	if(argc > 0) {
		kString *s = new_T(argv[0]);
		knh_DictMap_set(_ctx, ctx->share->props, new_T("script.name"), s);
		kbytes_t t = knh_bytes_nsname(S_tobytes(s));
		knh_Script_setNSName(_ctx, ctx->script, new_kString(t.text, t.len, SPOL_TEXT|SPOL_POOL));
	}
	else {
		knh_Script_setNSName(_ctx, ctx->script, TS_main);
	}
}

/* ------------------------------------------------------------------------ */

static int knh_runMain(CTX, int argc, const char **argv)
{
	KONOHA_BEGIN(_ctx);
	kMethod *mtd = ClassTBL_getMethodNULL(_ctx, O_ct(_ctx->script), MN_main);
	int res = 0;
	if(mtd != NULL) {
		int thisidx = 1 + K_CALLDELTA;
		BEGIN_LOCAL(_ctx, lsfp, 5);
		lsfp[1].ivalue = 0;
		lsfp[thisidx+K_PCIDX].pc = NULL;
		klr_setmtdNC(_ctx,lsfp[thisidx+K_MTDIDX], mtd);
		KSETv(lsfp[thisidx].o, ctx->script);
		KSETv(lsfp[thisidx+1].o, knh_getPropertyNULL(_ctx, STEXT("script.argv")));
		klr_setesp(_ctx, lsfp + thisidx+2);
		if(knh_VirtualMachine_launch(_ctx, lsfp + thisidx)) {
			res = (int)lsfp[1].ivalue;
		}
		END_LOCAL(_ctx, lsfp);
	}
	KONOHA_END(_ctx);
	return res;
}

/* ------------------------------------------------------------------------ */
/* [shell] */

static void knh_showWelcome(CTX, kOutputStream *w)
{
	const knh_sysinfo_t *sysinfo = knh_getsysinfo();
	knh_printf(_ctx, w, "%s%s %s(%s) %s (rev:%d, %s %s)%s\n",
		TERM_BBOLD(_ctx),
		sysinfo->konoha_type, sysinfo->konoha_version, sysinfo->konoha_codename,
		K_DISTTYPE, ((intptr_t)K_REVISION), __DATE__, __TIME__, TERM_EBOLD(_ctx));
	//knh_printf(_ctx, w, "[%s] on %s (%d, %s)\n", CC_TYPE, sysinfo->kern_ostype, sysinfo->konoha_systembits, knh_getSystemEncoding());
	knh_printf(_ctx, w, "options: %sused_memory:%d kb\n",
		sysinfo->konoha_options, (intptr_t)(_ctx->stat->usedMemorySize / 1024));
}

static int shell_checkstmt(kbytes_t t)
{
	size_t i = 0;
	int ch, quote = 0, nest = 0;
	int hasDOC = 0;
	L_NORMAL:
	for(; i < t.len; i++) {
		ch = t.ubuf[i];
		if(ch == '{' || ch == '[' || ch == '(') nest++;
		if(ch == '}' || ch == ']' || ch == ')') nest--;
		if(ch == '\'' || ch == '"' || ch == '`') {
			if(t.ubuf[i+1] == ch && t.ubuf[i+2] == ch) {
				quote = ch; i+=2;
				goto L_TQUOTE;
			}
		}
		if(ch == '\n') hasDOC = 0;
		if(ch == '#') {
			hasDOC = 1;
		}
	}
	return (hasDOC == 1) ? 1 : nest;
	L_TQUOTE:
	DBG_ASSERT(i > 0);
	for(; i < t.len; i++) {
		ch = t.ubuf[i];
		if(t.ubuf[i-1] != '\\' && ch == quote) {
			if(t.ubuf[i+1] == ch && t.ubuf[i+2] == ch) {
				i+=2;
				goto L_NORMAL;
			}
		}
	}
	return 1;
}

static void shell_restart(CTX)
{
//	kKonohaSpace *ns = new_KonohaSpace(_ctx, NULL);
//	DBG_ASSERT(ns->b->aliasDictMapNULL == NULL);
//	ctx->wshare->sysAliasDictMapNULL = DP(_ctx->share->rootks)->aliasDictMapNULL;
//	DP(_ctx->share->rootks)->aliasDictMapNULL = NULL;
//	KSETv(((kshare_t*)ctx->share)->rootks, ns);
//	KSETv(((kcontext_t*)ctx)->script, new_(Script));
//	{
//		kGammaBuilder *newgma = new_(GammaBuilder);
//		KSETv(((kcontext_t*)ctx)->gma, newgma);
//		KINITv(DP(newgma)->symbolDictMap, new_DictMap0(_ctx, 256, 0/*isCaseMap*/, "GammaBuilder.symbolDictMap"));
//		KINITv(DP(newgma)->constPools, new_Array0(_ctx, 0));
//		KINITv(DP(newgma)->script, ctx->script);
//	}
	KNH_TODO("restart");
}

void knh_dumpKeyword(CTX, kOutputStream *w);

static kstatus_t shell_command(CTX, const char *cmd)
{
	kbytes_t t = {{cmd}, knh_strlen(cmd)};
	if(B_equals(t, "quit") || B_equals(t, "exit") || B_equals(t, "bye")) {
		return K_BREAK;
	}
	if(B_equals(t, "keyword")) {
		knh_dumpKeyword(_ctx, KNH_STDOUT);
		return K_REDO;
	}
	if(B_equals(t, "restart")) {
		fputs(
"=============================================================================="
"\n\n\n", stdout);
		shell_restart(_ctx);
		return K_REDO;
	}
	return K_CONTINUE;
}


static int konoha_shell(CTX, char *optstr)
{
	KONOHA_BEGIN(_ctx);
	knh_loadScriptPackageList(_ctx, "konoha.i?");
#ifdef K_USING_SECURITY_ALERT
	knh_askSecfileidtyAlert(_ctx);
#endif
	CTX_setInteractive(_ctx, 1);
	knh_shell(_ctx);
	KONOHA_END(_ctx);
	return 0;
}

/* ------------------------------------------------------------------------- */

typedef knh_iconv_t (*ficonv_open)(const char *, const char *);
typedef size_t (*ficonv)(knh_iconv_t , char **, size_t *, char **, size_t *);
typedef int    (*ficonv_close)(knh_iconv_t);

static void knh_linkDynamicIconv(CTX)
{
	knh_ServiceSPI_t *spi = ((knh_ServiceSPI_t*)ctx->spi);
	void *handler = knh_dlopen(_ctx, "libiconv" K_OSDLLEXT);
	void *f = NULL;
	if(handler != NULL) {
		f = knh_dlsym(_ctx, handler, "iconv_open", "libiconv_open", 1/*isTest*/);
		if (f != NULL) {
			spi->iconvspi       = "libiconv";
			spi->iconv_openSPI  = (ficonv_open)f;
			spi->iconvSPI = (ficonv)knh_dlsym(_ctx, handler, "iconv", "libiconv", 0/*isTest*/);
			spi->iconv_closeSPI = (ficonv_close)knh_dlsym(_ctx, handler, "libiconv_close", "iconv_close", 0);
			KNH_ASSERT(spi->iconvSPI != NULL && spi->iconv_closeSPI != NULL);
			return ; // OK
		}
	}
	PleaseLetUsKnowYourOS("libiconv is not available");
}

/*************************************************************************** */

struct konoha_module_driver {
	const char *name;
	void (*init)(int argc, int n, const char **argv);
	void (*exit)(void);
};

static void ac_init(int argc, int n, const char **argv)
{
//	if(uout != NULL) {
//		fprintf(uout, "testing: %s\n", argv[n]);
//		fflush(uout);
//	}
}

static void ac_exit(void)
{
//	if(uout != NULL) {
//		fclose(uout);
//	}
}

#ifdef K_USING_LLVM
extern void knh_llvm_init(int, int, const char **);
extern void knh_llvm_exit(void);
#endif
struct konoha_module_driver konoha_modules[] = {
	{"ac", ac_init, ac_exit},
#ifdef K_USING_LLVM
	{"llvm", knh_llvm_init, knh_llvm_exit},
#endif
	{"null", NULL, NULL}
};

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#endif

int konoha_main(konoha_t konoha, int argc, const char **argv)
{
	CTX = (CTX)konoha;
	int i, ret = 0, n = knh_parseopt(_ctx, argc, argv);
	knh_linkDynamicReadline(_ctx);
	knh_linkDynamicRegex(_ctx);
	knh_linkDynamicIconv(_ctx);
	for (i = 0; konoha_modules[i].init != NULL; ++i) {
		konoha_modules[i].init(argc, n, argv);
	}
	argc = argc - n;
	argv = argv + n;
	if(isActorMode) {
		char portstr[6] = {0};
		knh_snprintf(portstr, sizeof(portstr), "%d", port);
		const char *argv_actor[3] = {"actsrv", portstr, NULL};
		argc = 2;
		argv = argv_actor;
	}
	knh_parsearg(_ctx, argc, argv);
	if(argc == 0) {
		ret = konoha_shell(_ctx, NULL);
	}
	else {
		if(knh_startScript(_ctx, argv[0]) == K_CONTINUE && !knh_isCompileOnly(_ctx)) {
			ret = knh_runMain(_ctx, argc, argv);
			if(isInteractiveMode) {
				konoha_shell(_ctx, NULL);
			}
		}
	}
	for (i = 0; konoha_modules[i].exit != NULL; ++i) {
		konoha_modules[i].exit();
	}
	return ret;
}

/*************************************************************************** */

#ifdef __cplusplus
}
#endif
